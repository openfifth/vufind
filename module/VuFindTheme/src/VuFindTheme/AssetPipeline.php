<?php

/**
 * Class to handle asset pipeline functionality.
 *
 * PHP version 8
 *
 * Copyright (C) Villanova University 2025.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * @category VuFind
 * @package  Theme
 * @author   Demian Katz <demian.katz@villanova.edu>
 * @license  http://opensource.org/licenses/gpl-2.0.php GNU General Public License
 * @link     https://vufind.org Main Site
 */

namespace VuFindTheme;

use Exception;
use Laminas\Log\LoggerAwareInterface;
use Laminas\View\Helper\Url;
use MatthiasMullie\Minify\Minify;
use VuFind\Log\LoggerAwareTrait;
use VuFindTheme\View\Helper\RelativePathTrait;

use function count;
use function defined;
use function in_array;
use function is_resource;

/**
 * Class to handle asset pipeline functionality.
 *
 * @category VuFind
 * @package  Theme
 * @author   Demian Katz <demian.katz@villanova.edu>
 * @license  http://opensource.org/licenses/gpl-2.0.php GNU General Public License
 * @link     https://vufind.org Main Site
 */
class AssetPipeline implements LoggerAwareInterface
{
    use LoggerAwareTrait;
    use RelativePathTrait;

    /**
     * Map of asset types to minifier classes.
     *
     * @var array
     */
    protected array $minifiers = [
        'css' => \VuFindTheme\Minify\CSS::class,
        'js' => \MatthiasMullie\Minify\JS::class,
    ];

    /**
     * Constructor
     *
     * @param ThemeInfo   $themeInfo      Theme information service
     * @param Url         $urlHelper      URL view helper
     * @param string|bool $pipelineConfig Config for current application environment
     * @param ?int        $maxImportSize  Maximum imported (inlined) file size
     */
    public function __construct(
        protected ThemeInfo $themeInfo,
        protected Url $urlHelper,
        protected string|bool $pipelineConfig,
        protected ?int $maxImportSize = null
    ) {
    }

    /**
     * Check if the pipeline is functional.
     *
     * @return bool
     */
    protected function isPipelineAvailable(): bool
    {
        try {
            $cacheDir = $this->getResourceCacheDir();
        } catch (\Exception $e) {
            $this->logError($e->getMessage());
            return false;
        }
        if ($cacheDir && !is_writable($cacheDir)) {
            $this->logError("Cannot write to $cacheDir; disabling asset pipeline.");
            return false;
        }
        return true;
    }

    /**
     * Check if config is enabled for the specified file type
     *
     * @param string $fileType File type to check for pipeline config
     *
     * @return bool
     */
    protected function isPipelineEnabledForType(string $fileType): bool
    {
        $config = $this->pipelineConfig;
        if ($config === false || $config === 'off' || $config === 'false' || $config === '0') {
            return false;
        }
        if ($config == '*' || $config === 'on' || $config === 'true' || $config === true || $config === '1') {
            return true;
        }
        $settings = array_map('trim', explode(',', $config));
        return in_array($fileType, $settings);
    }

    /**
     * Get the path to the directory where we can cache files generated by
     * this trait. The directory will be created if it does not already exist.
     *
     * @return string
     */
    protected function getResourceCacheDir(): string
    {
        if (!defined('LOCAL_CACHE_DIR')) {
            throw new \Exception(
                'Asset pipeline feature depends on the LOCAL_CACHE_DIR constant.'
            );
        }
        // TODO: it might be better to use \VuFind\Cache\Manager here.
        $cacheDir = LOCAL_CACHE_DIR . '/public/';
        if (!is_dir($cacheDir) && !file_exists($cacheDir)) {
            if (!mkdir($cacheDir)) {
                throw new \Exception("Unexpected problem creating cache directory: $cacheDir");
            }
        }
        return $cacheDir;
    }

    /**
     * Determine whether the asset is exempt from concatenation.
     *
     * @param array  $item Asset
     * @param string $type Type of asset (css or js)
     *
     * @return bool
     * @throws Exception
     */
    protected function isExcludedFromConcat(array $item, string $type): bool
    {
        if ($item['options']['exclude_from_pipeline'] ?? false) {
            return true;
        }
        if ($type === 'css') {
            return empty($item['href']) || !$this->isRelativePath($item['href']);
        } elseif ($type === 'js') {
            return empty($item['src'])
                || !empty($item['attrs']['conditional'])
                || !$this->isRelativePath($item['src']);
        }
        throw new Exception("Unknown type: $type");
    }

    /**
     * Extract the file path from an asset.
     *
     * @param array  $item Asset
     * @param string $type Type of asset (css or js)
     *
     * @return string
     * @throws Exception
     */
    protected function getResourceFilePath(array $item, string $type): string
    {
        $key = $this->getFileKeyByType($type);
        if (!isset($item[$key])) {
            throw new Exception("Unexpected missing $key key in $type item.");
        }
        return $item[$key];
    }

    /**
     * Get the group identification key for a specific asset.
     *
     * @param array  $item Asset
     * @param string $type Type of asset (css or js)
     *
     * @return string
     * @throws Exception
     */
    protected function getGroupType(array $item, string $type): string
    {
        if ($type === 'css') {
            $groupType = $item['media'] ?? 'all';
            if (isset($item['conditionalStylesheet'])) {
                $type .= '_' . $item['conditionalStylesheet'];
            }
            return $groupType;
        }
        return 'default';
    }

    /**
     * Get a group key value for the provided filename.
     *
     * @param string $file Filename
     *
     * @return string
     */
    protected function getKeyForFile(string $file): string
    {
        $mtime = filemtime($file);
        return $file . (string)($mtime ?: '');
    }

    /**
     * Sort assets into groups that can be collapsed using a minifier.
     *
     * @param array  $assets Assets to group
     * @param string $type   Type of assets (css or js)
     *
     * @return array
     * @throws Exception
     */
    protected function groupAssets(array $assets, string $type): array
    {
        $groups = [];
        $groupTypeIndex = [];

        foreach ($assets as $item) {
            if ($this->isExcludedFromConcat($item, $type)) {
                $groups[] = [
                    'other' => true,
                    'item' => $item,
                ];
                continue;
            }

            $path = $type . '/' . $this->getResourceFilePath($item, $type);
            $details = $this->themeInfo->findContainingTheme(
                $path,
                ThemeInfo::RETURN_ALL_DETAILS
            );
            // Deal with special case: $path was not found in any theme.
            if (null === $details) {
                $errorMsg = "Could not find file '$path' in theme files";
                $this->logError($errorMsg);
                $groups[] = [
                    'other' => true,
                    'item' => $item,
                ];
                continue;
            }

            $groupType = $this->getGroupType($item, $type);
            $index = $groupTypeIndex[$groupType] ?? false;
            if ($index === false) {
                $groupTypeIndex[$groupType] = count($groups);
                $groups[] = [
                    'items' => [$item],
                    'key' => $this->getKeyForFile($details['path']),
                ];
            } elseif (!in_array($item, $groups[$index]['items'])) {
                $groups[$index]['items'][] = $item;
                $groups[$index]['key'] .= $this->getKeyForFile($details['path']);
            }
        }

        return $groups;
    }

    /**
     * Check if a file is minifiable i.e. does not have a pattern that denotes it's
     * already minified
     *
     * @param string $filename File name
     *
     * @return bool
     */
    protected function isMinifiable(string $filename): bool
    {
        $basename = basename($filename);
        return preg_match('/\.min\.(js|css)/', $basename) === 0;
    }

    /**
     * Get the minifier object for the specified file type.
     *
     * @param string $type Type of assets (css or js)
     *
     * @return Minify
     * @throws Exception
     */
    protected function getMinifier(string $type): Minify
    {
        $minifierClass = $this->minifiers[$type] ?? null;
        if (!$minifierClass) {
            throw new Exception("Unsupported type: $type");
        }
        $minifier = new $minifierClass();
        if ($type === 'css' && null !== $this->maxImportSize) {
            $minifier->setMaxImportSize($this->maxImportSize);
        }
        return $minifier;
    }

    /**
     * Get minified data for a file
     *
     * @param array  $details    File details
     * @param string $concatPath Target path for the resulting file (used in minifier
     * for path mapping)
     * @param string $type       Type of assets (css or js)
     *
     * @throws \Exception
     * @return string
     */
    protected function getMinifiedData(array $details, string $concatPath, string $type): string
    {
        if ($this->isMinifiable($details['path'])) {
            $minifier = $this->getMinifier($type);
            $minifier->add($details['path']);
            $data = $minifier->execute($concatPath);
        } else {
            $data = file_get_contents($details['path']);
            if (false === $data) {
                throw new \Exception(
                    "Could not read file {$details['path']}"
                );
            }
        }
        // Play it safe by terminating Javascript code with a semicolon
        if ($type === 'js' && !str_ends_with(trim($data), ';')) {
            $data .= ';';
        }
        return $data;
    }

    /**
     * Create a concatenated file from the given group of files
     *
     * @param string $concatPath Resulting file path
     * @param array  $group      Object containing 'key' and stdobj file 'items'
     * @param string $type       Type of assets (css or js)
     *
     * @throws \Exception
     * @return void
     */
    protected function createConcatenatedFile(string $concatPath, array $group, string $type): void
    {
        $data = [];
        foreach ($group['items'] as $item) {
            $details = $this->themeInfo->findContainingTheme(
                $type . '/' . $this->getResourceFilePath($item, $type),
                ThemeInfo::RETURN_ALL_DETAILS
            );
            $details['path'] = realpath($details['path']);
            $data[] = $this->getMinifiedData($details, $concatPath, $type);
        }
        // Separate each file's data with a new line so that e.g. a file
        // ending in a comment doesn't cause the next one to also get commented out.
        file_put_contents($concatPath, implode("\n", $data));
    }

    /**
     * Using the concatKey, return the path of the concatenated file.
     * Generate if it does not yet exist.
     *
     * @param array  $group Grouped assets
     * @param string $type  Type of assets (css or js)
     *
     * @return string
     */
    protected function getConcatenatedFilePath(array $group, string $type): string
    {
        // Don't recompress individual files
        if (count($group['items']) === 1) {
            $path = $this->getResourceFilePath($group['items'][0], $type);
            $details = $this->themeInfo->findContainingTheme(
                $type . '/' . $path,
                ThemeInfo::RETURN_ALL_DETAILS
            );
            return ($this->urlHelper)('home') . 'themes/' . $details['theme']
                . '/' . $type . '/' . $path;
        }
        // Locate/create concatenated asset file
        $filename = md5($group['key']) . '.min.' . $type;
        // Minifier uses realpath, so do that here too to make sure we're not
        // pointing to a symlink. Otherwise the path converter won't find the correct
        // shared directory part.
        $concatPath = realpath($this->getResourceCacheDir()) . '/' . $filename;
        if (!file_exists($concatPath)) {
            $lockfile = "$concatPath.lock";
            $handle = fopen($lockfile, 'c+');
            if (!is_resource($handle)) {
                throw new \Exception("Could not open lock file $lockfile");
            }
            if (!flock($handle, LOCK_EX)) {
                fclose($handle);
                throw new \Exception("Could not lock file $lockfile");
            }
            // Check again if file exists after acquiring the lock
            if (!file_exists($concatPath)) {
                try {
                    $this->createConcatenatedFile($concatPath, $group, $type);
                } catch (\Exception $e) {
                    flock($handle, LOCK_UN);
                    fclose($handle);
                    throw $e;
                }
            }
            flock($handle, LOCK_UN);
            fclose($handle);
        }

        return ($this->urlHelper)('home') . 'cache/' . $filename;
    }

    /**
     * Get the key name from the asset array where a filename/path can be set.
     *
     * @param string $type Type of assets (css or js)
     *
     * @return string
     * @throws Exception
     */
    protected function getFileKeyByType(string $type): string
    {
        $keys = ['css' => 'href', 'js' => 'src'];
        if (isset($keys[$type])) {
            return $keys[$type];
        }
        throw new Exception("Unexpected type: $type");
    }

    /**
     * Turn the output of groupAssets() into an array suitable for input to the view helpers.
     *
     * @param array  $groups Grouped assets returned by groupAssets()
     * @param string $type   Type of assets (css or js)
     *
     * @return array
     * @throws Exception
     */
    protected function processGroupedAssets(array $groups, string $type): array
    {
        $assets = [];

        foreach ($groups as $group) {
            if (isset($group['other'])) {
                $assets[] = $group['item'];
            } else {
                $item = $group['items'][0];
                $item[$this->getFileKeyByType($type)] = $this->getConcatenatedFilePath($group, $type);
                $assets[] = $item;
            }
        }

        return $assets;
    }

    /**
     * Process an array of assets through the pipeline.
     *
     * @param array  $assets Assets to process
     * @param string $type   Type of assets (css or js)
     *
     * @return array
     * @throws Exception
     */
    public function process(array $assets, string $type): array
    {
        if (!$this->isPipelineEnabledForType($type) || !$this->isPipelineAvailable()) {
            return $assets;
        }

        $groupedAssets = $this->groupAssets($assets, $type);
        return $this->processGroupedAssets($groupedAssets, $type);
    }
}
